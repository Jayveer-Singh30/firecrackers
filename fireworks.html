<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sky Fireworks Show</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: radial-gradient(circle at bottom, #000010 10%, #020214 80%);
        }
    </style>
</head>

<body>
    <script src="https://unpkg.com/three@0.152.2/build/three.min.js"></script>
    <script>
        let scene, camera, renderer;
        let fireworks = [];
        let audioCtx, audioInitialized = false;

        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(60, innerWidth / innerHeight, 1, 2000);
            camera.position.set(0, 150, 400);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(innerWidth, innerHeight);
            document.body.appendChild(renderer.domElement);

            const light = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(light);

            window.addEventListener('resize', onWindowResize);
            window.addEventListener('click', initAudio);
        }

        function onWindowResize() {
            camera.aspect = innerWidth / innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(innerWidth, innerHeight);
        }

        class Launcher {
            constructor(x, y, z, targetY) {
                this.pos = new THREE.Vector3(x, -200, z);
                this.targetY = targetY;
                this.velocity = new THREE.Vector3((Math.random() - 0.5) * 1, 3 + Math.random() * 1.5, (Math.random() - 0.5) * 1);
                this.color = new THREE.Color(`hsl(${Math.random() * 360},100%,60%)`);

                const mat = new THREE.PointsMaterial({
                    size: 8,
                    color: this.color,
                    transparent: true,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });
                const geo = new THREE.BufferGeometry().setFromPoints([this.pos]);
                this.points = new THREE.Points(geo, mat);
                scene.add(this.points);
                this.exploded = false;

                playLaunchSound();
            }

            update() {
                if (!this.exploded) {
                    this.pos.add(this.velocity);
                    this.velocity.y -= 0.02; // gravity
                    this.points.geometry.setFromPoints([this.pos]);
                    if (this.pos.y >= this.targetY || this.velocity.y <= 0) {
                        this.exploded = true;
                        scene.remove(this.points);
                        createExplosion(this.pos.x, this.pos.y, this.pos.z);
                    }
                }
            }
        }

        class Explosion {
            constructor(x, y, z, pattern) {
                this.pos = new THREE.Vector3(x, y, z);
                this.life = 1.0;
                this.velocities = [];
                this.count = 600;
                this.color = new THREE.Color(`hsl(${Math.random() * 360},100%,60%)`);

                const geom = new THREE.BufferGeometry();
                const positions = [];
                const colors = [];

                const patternPoints = this.makePattern(pattern, this.count);
                for (let p of patternPoints) {
                    positions.push(p.x, p.y, p.z);
                    const c = this.color.clone();
                    colors.push(c.r, c.g, c.b);
                    this.velocities.push(p.clone().multiplyScalar(0.15 + Math.random() * 0.1));
                }

                geom.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                geom.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

                const mat = new THREE.PointsMaterial({
                    size: 4,
                    vertexColors: true,
                    transparent: true,
                    opacity: 1,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });

                this.points = new THREE.Points(geom, mat);
                this.points.position.copy(this.pos);
                scene.add(this.points);

                playExplosionSound();
            }

            makePattern(type, count) {
                const pts = [];
                if (type === 'heart') {
                    for (let i = 0; i < count; i++) {
                        const t = Math.PI * 2 * (i / count);
                        const x = 16 * Math.pow(Math.sin(t), 3);
                        const y = 13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t);
                        pts.push(new THREE.Vector3(x, y, 0).multiplyScalar(2));
                    }
                } else if (type === 'star') {
                    const spikes = 5;
                    for (let i = 0; i < count; i++) {
                        const angle = (i / count) * Math.PI * 2;
                        const r = i % 2 === 0 ? 10 : 4;
                        pts.push(new THREE.Vector3(Math.cos(angle) * r, Math.sin(angle) * r, 0).multiplyScalar(4));
                    }
                } else if (type === 'ring') {
                    for (let i = 0; i < count; i++) {
                        const a = (i / count) * Math.PI * 2;
                        pts.push(new THREE.Vector3(Math.cos(a) * 20, Math.sin(a) * 20, 0));
                    }
                } else {
                    for (let i = 0; i < count; i++) {
                        const a = Math.random() * Math.PI * 2;
                        const b = Math.random() * Math.PI;
                        const r = 15 + Math.random() * 5;
                        pts.push(new THREE.Vector3(
                            Math.sin(b) * Math.cos(a) * r,
                            Math.sin(b) * Math.sin(a) * r,
                            Math.cos(b) * r
                        ));
                    }
                }
                return pts;
            }

            update() {
                const pos = this.points.geometry.attributes.position;
                for (let i = 0; i < this.velocities.length; i++) {
                    pos.array[i * 3] += this.velocities[i].x;
                    pos.array[i * 3 + 1] += this.velocities[i].y - 0.02;
                    pos.array[i * 3 + 2] += this.velocities[i].z;
                    this.velocities[i].multiplyScalar(0.97);
                }
                this.life -= 0.01;
                this.points.material.opacity = this.life;
                pos.needsUpdate = true;
            }

            done() {
                return this.life <= 0;
            }
        }

        function createLauncher(x, y, z, targetY) {
            fireworks.push(new Launcher(x, y, z, targetY));
        }

        function createExplosion(x, y, z) {
            const patterns = ['heart', 'star', 'ring', 'random'];
            const pattern = patterns[Math.floor(Math.random() * patterns.length)];
            fireworks.push(new Explosion(x, y, z, pattern));
        }

        function animate() {
            requestAnimationFrame(animate);
            fireworks.forEach((fw, i) => {
                fw.update();
                if (fw.done && fw.done()) {
                    scene.remove(fw.points);
                    fireworks.splice(i, 1);
                }
            });
            renderer.render(scene, camera);

            // Launch fireworks from random positions across the screen
            if (Math.random() < 0.02) {
                const x = (Math.random() - 0.5) * 800;
                const z = (Math.random() - 0.5) * 400;
                const targetY = 100 + Math.random() * 250;
                createLauncher(x, targetY, z, targetY);
            }
        }

        /* === SOUND === */
        function initAudio() {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            }
            if (audioCtx.state === 'suspended') audioCtx.resume();
            audioInitialized = true;
        }

        function playLaunchSound() {
            if (!audioInitialized) return;
            const now = audioCtx.currentTime;
            const osc = audioCtx.createOscillator();
            osc.type = 'sine';
            osc.frequency.setValueAtTime(200, now);
            osc.frequency.exponentialRampToValueAtTime(1000, now + 0.5);
            const gain = audioCtx.createGain();
            gain.gain.setValueAtTime(0.1, now);
            gain.gain.exponentialRampToValueAtTime(0.001, now + 0.5);
            osc.connect(gain).connect(audioCtx.destination);
            osc.start();
            osc.stop(now + 0.5);
        }

        function playExplosionSound() {
            if (!audioInitialized) return;
            const now = audioCtx.currentTime;
            const bufferSize = audioCtx.sampleRate * 0.3;
            const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
            const noise = audioCtx.createBufferSource();
            noise.buffer = buffer;
            const filter = audioCtx.createBiquadFilter();
            filter.type = 'bandpass';
            filter.frequency.setValueAtTime(800, now);
            const gain = audioCtx.createGain();
            gain.gain.setValueAtTime(0.3, now);
            gain.gain.exponentialRampToValueAtTime(0.001, now + 0.4);
            noise.connect(filter).connect(gain).connect(audioCtx.destination);
            noise.start();
            noise.stop(now + 0.4);
        }
    </script>
</body>

</html>